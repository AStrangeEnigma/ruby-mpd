<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>
  File: README
  
    &mdash; Documentation by YARD 0.8.3
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '';
  framesUrl = "frames.html#!" + escape(window.location.href);
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><div id='filecontents'><h1>Librmpd and You</h1>

<p>librmpd is a simple yet powerful library for the
<a href="http://www.musicpd.org">Music Player Daemon</a>, written in Ruby.</p>

<h2>Goals</h2>

<p>The goal of librmpd is to provide MPD client creators with a simple
interface that allows for the rapid development of clients. This is
accomplished by implementing a callback interface in the library itself,
rather than leaving this up to the client developer. librmpd also provides
thread safety for its calls to the server, allowing multiple threads to
make use of one socket.</p>

<h2>MPD Potocol</h2>

<p>The Music Player Daemon protocol is implemented in the MPD class. This class
contains most of the commands used in communicating with the server. Some of
the commands were removed/modified to make the usage more transparent. Gone
are the confusing <code>lsinfo</code> and <code>listallinfo</code> variations on listing data
from the server. Instead these are replaced with straightforward methods,
such as <code>artists</code> to get all artists and <code>songs</code> to get all songs.</p>

<h2>Usage</h2>

<p>All functionality is contained in the MPD class. Creating an instance of this
class is as simple as</p>

<pre class="code ruby"><code><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>rubygems</span><span class='tstring_end'>'</span></span>
<span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>librmpd</span><span class='tstring_end'>'</span></span>

<span class='id identifier rubyid_mpd'>mpd</span> <span class='op'>=</span> <span class='const'>MPD</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>localhost</span><span class='tstring_end'>'</span></span><span class='comma'>,</span> <span class='int'>6600</span>
</code></pre>

<p>Once you have an instance of the MPD class, start by connecting to the server:</p>

<pre class="code ruby"><code><span class='id identifier rubyid_mpd'>mpd</span><span class='period'>.</span><span class='id identifier rubyid_connect'>connect</span>
</code></pre>

<p>When you are done, disconnect by calling disconnect</p>

<pre class="code ruby"><code><span class='id identifier rubyid_mpd'>mpd</span><span class='period'>.</span><span class='id identifier rubyid_disconnect'>disconnect</span>
</code></pre>

<p><em>Note</em>: The server may disconnect you at any time due to inactivity. This can
be fixed by enabling callbacks (see the Callbacks section) or by issuing a
<code>ping</code> command at certain intervals</p>

<p>Once connected, you can issue commands to talk to the server</p>

<pre class="code ruby"><code><span class='id identifier rubyid_mpd'>mpd</span><span class='period'>.</span><span class='id identifier rubyid_connect'>connect</span>
<span class='kw'>if</span> <span class='id identifier rubyid_mpd'>mpd</span><span class='period'>.</span><span class='id identifier rubyid_stopped?'>stopped?</span>
  <span class='id identifier rubyid_mpd'>mpd</span><span class='period'>.</span><span class='id identifier rubyid_play'>play</span>
<span class='kw'>end</span>
<span class='id identifier rubyid_song'>song</span> <span class='op'>=</span> <span class='id identifier rubyid_mpd'>mpd</span><span class='period'>.</span><span class='id identifier rubyid_current_song'>current_song</span>
<span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Current Song: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_song'>song</span><span class='period'>.</span><span class='id identifier rubyid_artist'>artist</span><span class='rbrace'>}</span><span class='tstring_content'> - </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_song'>song</span><span class='period'>.</span><span class='id identifier rubyid_title'>title</span><span class='rbrace'>}</span><span class='tstring_end'>&quot;</span></span>
</code></pre>

<p>You can find documentation for each command <a href="http://librmpd.rubyforge.org/docs">here</a></p>

<h2>Callbacks</h2>

<p>Callbacks are a simple way to make your client respond to events, rather that have to continuously ask the server for updates. This allows you (the client creator) to focus on displaying the data, rather that working overly hard to get it. This is done by having a background thread continuously check the server for changes. Because of this thead, enabling callbacks also means your client will stay connected to the server without having to worry about timeouts.</p>

<p>To make use of callbacks, the following steps are taken:</p>

<ol>
<li>Setup a method to be called when something happens. This is called the callback method.</li>
<li>Tell librmpd about your callback method by adding it to the appropriate list of callbacks.</li>
<li>Connect to the server with callbacks set as enabled.</li>
<li>???</li>
<li>Profit!</li>
</ol>

<p>Ok, so the first three are all you really need. Lets look at step one: Setup a method to be called when something happens. Each callback method will be given specific data relevant to that callback. For example, the state changed callback passes the new state to the callback. This means your state callback method has to be defined as taking one argument:</p>

<pre class="code ruby"><code>class MyClient
  ...
  def my_state_callback( newstate )
    puts &quot;MPD Changed State: #{newstate}&quot;
  end
  ...
end
</code></pre>

<p>That&#39;s it. As long as your defined method matches what the callback&#39;s requirements are, you&#39;re good to go. You can see the requirements for each callback under the CONSTANTS section <a href="http://librmpd.rubyforge.org/docs/classes/MPD.html">here</a></p>

<p>In step two, you have to actually inform librmpd about the callback, and which callback it belongs to. This is done by the <code>register_callback</code> method. <code>register_callback</code> takes two arguments, first, the Method object of the callback method, and second, the type of callback to register this method as. Sound complicated? its not. Using the above example callback, here&#39;s how we&#39;d tell librmpd about it:</p>

<pre class="code ruby"><code><span class='id identifier rubyid_client'>client</span> <span class='op'>=</span> <span class='const'>MyClient</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_state_cb'>state_cb</span> <span class='op'>=</span> <span class='id identifier rubyid_client'>client</span><span class='period'>.</span><span class='id identifier rubyid_method'>method</span> <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>my_state_callback</span><span class='tstring_end'>'</span></span>
<span class='id identifier rubyid_mpd'>mpd</span><span class='period'>.</span><span class='id identifier rubyid_register_callback'>register_callback</span> <span class='id identifier rubyid_state_cb'>state_cb</span><span class='comma'>,</span> <span class='const'>MPD</span><span class='op'>::</span><span class='const'>STATE_CALLBACK</span>
</code></pre>

<p>Blammo! that&#39;s it. The second line is the biggy. the <code>method</code> method returns a Method object which can then be called at some arbitrary point in time. This Method object is stored in a list inside librmpd, so whenever the state changes, all of the Method objects in that list are then informed of the change. Since they&#39;re stored in a list, this means you are free to add as many callbacks as you want, without side effects.</p>

<p>Finally, the easiest step. In order for callbacks to work, you must connect to the server with callbacks enabled:</p>

<pre class="code ruby"><code><span class='id identifier rubyid_mpd'>mpd</span><span class='period'>.</span><span class='id identifier rubyid_connect'>connect</span> <span class='kw'>true</span>
</code></pre>

<p>Easy as pie. The above will connect to the server like normal, but this time it will create a new thread that loops until you issue a <code>disconnect</code>. This loop checks the server, then sleeps for two tenths of a second, then loops. Because it&#39;s continuously polling the server, there&#39;s the added benefit of your client not being disconnected due to inactivity.</p>

<h2>Example Clients</h2>

<p>Inside the release tar/zip, there is an example directory that contains two very simple clients. The first client, <code>rmpc.rb</code> behaves just like mpc. This is just a command line client that lets you issue a single command such as</p>

<pre class="code ruby"><code>$ rmpc.rb play
</code></pre>

<p>and thats it. The second client, <code>tailmpc.rb</code> is a client that uses callbacks to print server information out to the console</p>

<pre class="code ruby"><code>$ tailmpc.rb
Starting TailMPC - Press Ctrl-D to quit

MPD Status: play
Current Song: Some Song.mp3
...
MPD Status: stop
</code></pre>

<p>The <code>TIME_CALLBACK</code> by default is not enabled (since it would spew output every second) but can be enabled by editing the source.</p>
</div></div>

    <div id="footer">
  Generated on Sun Jan 13 11:21:24 2013 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.3 (ruby-1.9.3).
</div>

  </body>
</html>